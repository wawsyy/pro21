"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These will be generated by genabi.mjs script
import { StrengthTrackerAddresses } from "@/abi/StrengthTrackerAddresses";
import { StrengthTrackerABI } from "@/abi/StrengthTrackerABI";

export type TrainingRecord = {
  index: number;
  weightHandle: string;
  setsHandle: string;
  repsHandle: string;
  timestamp: bigint;
  decrypted?: {
    weight: bigint;
    sets: bigint;
    reps: bigint;
  };
};

type StrengthTrackerInfoType = {
  abi: typeof StrengthTrackerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getStrengthTrackerByChainId(
  chainId: number | undefined
): StrengthTrackerInfoType {
  if (!chainId) {
    return { abi: StrengthTrackerABI.abi };
  }

  const entry =
    StrengthTrackerAddresses[
      chainId.toString() as keyof typeof StrengthTrackerAddresses
    ];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: StrengthTrackerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: StrengthTrackerABI.abi,
  };
}

export const useStrengthTracker = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [records, setRecords] = useState<TrainingRecord[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const strengthTrackerRef = useRef<StrengthTrackerInfoType | undefined>(
    undefined
  );
  const isRecordingRef = useRef<boolean>(false);
  const isDecryptingRef = useRef<boolean>(false);
  const isLoadingRef = useRef<boolean>(false);
  const lastLoadedAddressRef = useRef<string | undefined>(undefined);

  const strengthTracker = useMemo(() => {
    const c = getStrengthTrackerByChainId(chainId);
    strengthTrackerRef.current = c;

    if (!c.address) {
      setMessage(`StrengthTracker deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!strengthTracker) {
      return undefined;
    }
    return (
      Boolean(strengthTracker.address) &&
      strengthTracker.address !== ethers.ZeroAddress
    );
  }, [strengthTracker]);

  const canRecord = useMemo(() => {
    return (
      strengthTracker.address &&
      instance &&
      ethersSigner &&
      !isRecording &&
      !isLoading
    );
  }, [strengthTracker.address, instance, ethersSigner, isRecording, isLoading]);

  const canLoadRecords = useMemo(() => {
    return (
      strengthTracker.address &&
      ethersReadonlyProvider &&
      !isLoading &&
      ethersSigner
    );
  }, [
    strengthTracker.address,
    ethersReadonlyProvider,
    isLoading,
    ethersSigner,
  ]);

  const loadRecords = useCallback(() => {
    if (
      isLoadingRef.current ||
      isLoading ||
      !strengthTracker.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      return;
    }

    // Check if we already loaded for this address
    const currentKey = `${strengthTracker.address}-${ethersSigner.address}-${chainId}`;
    if (lastLoadedAddressRef.current === currentKey) {
      return;
    }

    isLoadingRef.current = true;
    setIsLoading(true);
    setMessage("Loading records...");

    const thisChainId = chainId;
    const thisStrengthTrackerAddress = strengthTracker.address;
    const thisEthersSigner = ethersSigner;

    const contract = new ethers.Contract(
      thisStrengthTrackerAddress,
      strengthTracker.abi,
      ethersReadonlyProvider
    );

    contract
      .getRecordCount(thisEthersSigner.address)
      .then(async (count: bigint) => {
        if (
          !sameChain.current(thisChainId) ||
          thisStrengthTrackerAddress !== strengthTrackerRef.current?.address
        ) {
          return;
        }

        const recordCount = Number(count);
        const newRecords: TrainingRecord[] = [];

        for (let i = 0; i < recordCount; i++) {
          const [weightHandle, setsHandle, repsHandle, timestamp] =
            await contract.getRecord(thisEthersSigner.address, i);

          newRecords.push({
            index: i,
            weightHandle,
            setsHandle,
            repsHandle,
            timestamp,
          });
        }

        if (
          sameChain.current(thisChainId) &&
          thisStrengthTrackerAddress === strengthTrackerRef.current?.address
        ) {
          setRecords(newRecords);
          setMessage(`Loaded ${recordCount} record(s)`);
          lastLoadedAddressRef.current = currentKey;
        }
      })
      .catch((e: Error) => {
        setMessage("Failed to load records: " + e.message);
      })
      .finally(() => {
        isLoadingRef.current = false;
        setIsLoading(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, chainId, strengthTracker.address, sameChain]);

  useEffect(() => {
    // Only load when address, signer, or chainId changes
    const currentKey = `${strengthTracker.address}-${ethersSigner?.address}-${chainId}`;
    if (
      strengthTracker.address &&
      ethersReadonlyProvider &&
      ethersSigner &&
      lastLoadedAddressRef.current !== currentKey
    ) {
      loadRecords();
    }
  }, [strengthTracker.address, ethersSigner?.address, chainId, ethersReadonlyProvider, loadRecords]);

  const recordTraining = useCallback(
    (weight: number, sets: number, reps: number) => {
      if (
        isRecordingRef.current ||
        !strengthTracker.address ||
        !instance ||
        !ethersSigner
      ) {
        return;
      }

      const thisChainId = chainId;
      const thisStrengthTrackerAddress = strengthTracker.address;
      const thisEthersSigner = ethersSigner;

      const contract = new ethers.Contract(
        thisStrengthTrackerAddress,
        strengthTracker.abi,
        thisEthersSigner
      );

      isRecordingRef.current = true;
      setIsRecording(true);
      setMessage("Encrypting training data...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisStrengthTrackerAddress !== strengthTrackerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const weightInput = instance.createEncryptedInput(
            thisStrengthTrackerAddress,
            thisEthersSigner.address
          );
          weightInput.add32(weight);
          
          let encryptedWeight;
          try {
            encryptedWeight = await weightInput.encrypt();
          } catch (encryptError) {
            const errorMsg = (encryptError as Error).message || String(encryptError);
            if (errorMsg.includes("Relayer didn't response") || errorMsg.includes("Bad JSON") || errorMsg.includes("CONNECTION_CLOSED")) {
              setMessage("FHEVM Relayer service is unavailable. Please try again later or use local Hardhat network for testing.");
              throw new Error(`FHEVM Relayer unavailable: ${errorMsg}. The Sepolia testnet relayer service may be temporarily down. Please check https://relayer.testnet.zama.cloud status or use local Hardhat network (chainId: 31337) for development.`);
            }
            throw encryptError;
          }

          const setsInput = instance.createEncryptedInput(
            thisStrengthTrackerAddress,
            thisEthersSigner.address
          );
          setsInput.add32(sets);
          
          let encryptedSets;
          try {
            encryptedSets = await setsInput.encrypt();
          } catch (encryptError) {
            const errorMsg = (encryptError as Error).message || String(encryptError);
            if (errorMsg.includes("Relayer didn't response") || errorMsg.includes("Bad JSON") || errorMsg.includes("CONNECTION_CLOSED")) {
              setMessage("FHEVM Relayer service is unavailable. Please try again later or use local Hardhat network for testing.");
              throw new Error(`FHEVM Relayer unavailable: ${errorMsg}. The Sepolia testnet relayer service may be temporarily down. Please check https://relayer.testnet.zama.cloud status or use local Hardhat network (chainId: 31337) for development.`);
            }
            throw encryptError;
          }

          const repsInput = instance.createEncryptedInput(
            thisStrengthTrackerAddress,
            thisEthersSigner.address
          );
          repsInput.add32(reps);
          
          let encryptedReps;
          try {
            encryptedReps = await repsInput.encrypt();
          } catch (encryptError) {
            const errorMsg = (encryptError as Error).message || String(encryptError);
            if (errorMsg.includes("Relayer didn't response") || errorMsg.includes("Bad JSON") || errorMsg.includes("CONNECTION_CLOSED")) {
              setMessage("FHEVM Relayer service is unavailable. Please try again later or use local Hardhat network for testing.");
              throw new Error(`FHEVM Relayer unavailable: ${errorMsg}. The Sepolia testnet relayer service may be temporarily down. Please check https://relayer.testnet.zama.cloud status or use local Hardhat network (chainId: 31337) for development.`);
            }
            throw encryptError;
          }

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Submitting transaction...");

          const tx = await contract.recordTraining(
            encryptedWeight.handles[0],
            encryptedSets.handles[0],
            encryptedReps.handles[0],
            encryptedWeight.inputProof,
            encryptedSets.inputProof,
            encryptedReps.inputProof
          );

          setMessage(`Waiting for tx: ${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(
            `Training recorded! Status: ${receipt?.status === 1 ? "Success" : "Failed"}`
          );

          if (isStale()) {
            return;
          }

          // Reset the loaded address to force reload
          lastLoadedAddressRef.current = undefined;
          loadRecords();
        } catch (e) {
          const error = e as Error;
          const errorMsg = error.message || String(e);
          
          // Provide more helpful error messages
          if (errorMsg.includes("FHEVM Relayer unavailable")) {
            setMessage(errorMsg);
          } else if (errorMsg.includes("Relayer didn't response") || errorMsg.includes("Bad JSON")) {
            setMessage(`Failed to record training: FHEVM Relayer service error. The Sepolia testnet relayer (https://relayer.testnet.zama.cloud) may be temporarily unavailable. Please try again later or switch to local Hardhat network (chainId: 31337) for development. Original error: ${errorMsg}`);
          } else {
            setMessage("Failed to record training: " + errorMsg);
          }
        } finally {
          isRecordingRef.current = false;
          setIsRecording(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      strengthTracker.address,
      strengthTracker.abi,
      instance,
      chainId,
      loadRecords,
      sameChain,
      sameSigner,
    ]
  );

  const decryptRecord = useCallback(
    async (recordIndex: number) => {
      if (
        isDecryptingRef.current ||
        !strengthTracker.address ||
        !instance ||
        !ethersSigner
      ) {
        return;
      }

      const record = records[recordIndex];
      if (!record || record.decrypted) {
        return;
      }

      const thisChainId = chainId;
      const thisStrengthTrackerAddress = strengthTracker.address;
      const thisEthersSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting record ${recordIndex + 1}...`);

      const run = async () => {
        const isStale = () =>
          thisStrengthTrackerAddress !== strengthTrackerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig: FhevmDecryptionSignature | null =
            await FhevmDecryptionSignature.loadOrSign(
              instance,
              [strengthTracker.address as `0x${string}`],
              ethersSigner,
              fhevmDecryptionSignatureStorage
            );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Decrypting data...");

          // Wait a bit for event logs to stabilize (especially important for mock mode)
          await new Promise((resolve) => setTimeout(resolve, 500));

          // Helper function to decrypt with retry logic for mock mode
          const decryptWithRetry = async (
            handle: string,
            contractAddress: string,
            maxRetries = 3,
            retryDelay = 1000
          ) => {
            let lastError: Error | undefined;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
              try {
                const result = await instance.userDecrypt(
                  [
                    {
                      handle,
                      contractAddress,
                    },
                  ],
                  sig.privateKey,
                  sig.publicKey,
                  sig.signature,
                  sig.contractAddresses,
                  sig.userAddress,
                  sig.startTimestamp,
                  sig.durationDays
                );
                return result;
              } catch (error) {
                lastError = error as Error;
                // Check if it's the "backward order" error that can be retried
                const errorMessage = lastError.message || String(lastError);
                const errorString = JSON.stringify(error);
                if (
                  errorMessage.includes("backward order") ||
                  errorMessage.includes("Parse event") ||
                  errorString.includes("backward order") ||
                  errorString.includes("Parse event")
                ) {
                  if (attempt < maxRetries - 1) {
                    // Wait before retrying with exponential backoff
                    const delay = retryDelay * Math.pow(2, attempt);
                    setMessage(`Decrypting data... (retry ${attempt + 1}/${maxRetries})`);
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    continue;
                  }
                }
                // For other errors, throw immediately
                throw error;
              }
            }
            throw lastError || new Error("Decryption failed after retries");
          };

          const [weightResult, setsResult, repsResult] = await Promise.all([
            decryptWithRetry(
              record.weightHandle,
              thisStrengthTrackerAddress
            ),
            decryptWithRetry(
              record.setsHandle,
              thisStrengthTrackerAddress
            ),
            decryptWithRetry(
              record.repsHandle,
              thisStrengthTrackerAddress
            ),
          ]);

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          // Convert decryption results to bigint, handling string | bigint | boolean types
          const toBigInt = (value: string | bigint | boolean | undefined): bigint => {
            if (value === undefined || value === null) return BigInt(0);
            if (typeof value === "bigint") return value;
            if (typeof value === "boolean") return value ? BigInt(1) : BigInt(0);
            if (typeof value === "string") {
              try {
                return BigInt(value);
              } catch {
                return BigInt(0);
              }
            }
            return BigInt(0);
          };

          const decryptedWeight = toBigInt(weightResult[record.weightHandle]);
          const decryptedSets = toBigInt(setsResult[record.setsHandle]);
          const decryptedReps = toBigInt(repsResult[record.repsHandle]);

          setRecords((prev) => {
            const updated = [...prev];
            updated[recordIndex] = {
              ...updated[recordIndex],
              decrypted: {
                weight: decryptedWeight,
                sets: decryptedSets,
                reps: decryptedReps,
              },
            };
            return updated;
          });

          setMessage(
            `Decrypted: Weight=${decryptedWeight}kg, Sets=${decryptedSets}, Reps=${decryptedReps}`
          );
        } catch (e) {
          setMessage("Failed to decrypt: " + (e as Error).message);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      records,
      strengthTracker.address,
      instance,
      ethersSigner,
      chainId,
      fhevmDecryptionSignatureStorage,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: strengthTracker.address,
    isDeployed,
    canRecord,
    canLoadRecords,
    recordTraining,
    decryptRecord,
    loadRecords,
    records,
    isLoading,
    isRecording,
    isDecrypting,
    message,
  };
};


